<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texture2d Splitter</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background-color: #f8f9fa;
            padding: 20px 0;
        }
        .card {
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            border: none;
        }
        .card-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
        }
        .file-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #f8f9fa;
            min-height: 120px;
        }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .preview-container {
            min-height: 250px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 2px dashed #dee2e6;
        }
        .preview-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 5px;
        }
        .btn-primary {
            background: linear-gradient(135deg, #6c5ce7 0%, #3498db 100%);
            border: none;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #5d4ae0 0%, #2980b9 100%);
        }
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border: none;
        }
        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            border: none;
        }
        .feature-icon {
            font-size: 1.2rem;
            margin-right: 5px;
            color: #6c5ce7;
        }
        .drop-zone {
            border: 2px dashed #6c5ce7;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
            background-color: rgba(108, 92, 231, 0.05);
            transition: all 0.3s;
            margin-bottom: 15px;
        }
        .drop-zone.drag-over {
            background-color: rgba(108, 92, 231, 0.2);
            border-color: #3498db;
        }
        .sprite-preview {
            width: 80px;
            height: 80px;
            object-fit: contain;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 2px;
            background: white;
        }
        .sprite-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .sprite-card {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            background: white;
            transition: all 0.2s;
            position: relative;
        }
        .sprite-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .sprite-card.selected {
            border: 2px solid #6c5ce7;
            background-color: #f0f5ff;
        }
        .sprites-container {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .status-bar {
            background-color: #e9ecef;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin-top: 15px;
        }
        .info-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .right-panel {
            position: sticky;
            top: 20px;
            height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .sticky-preview {
            position: sticky;
            top: 0;
            z-index: 100;
            background: white;
            padding-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
        }
        .selection-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .sprite-checkbox {
            position: absolute;
            top: 5px;
            left: 5px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <!-- Info Modal -->
    <div class="modal fade" id="infoModal" tabindex="-1" aria-labelledby="infoModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="infoModalLabel"><i class="fas fa-info-circle"></i> How to Use This Tool</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <ol>
                        <li>Add your <strong>MonoBehaviour JSON files</strong> (from Unity sprite atlases)</li>
                        <li>Add the corresponding <strong>texture files</strong> (PNG, JPG, etc.)</li>
                        <li>Click <strong>Process Atlas</strong> to extract sprites</li>
                        <li>Select sprites to download and click <strong>Download Selected</strong></li>
                        <li>Use <strong>Select All</strong> or <strong>Deselect All</strong> to manage selections</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="row">
                <div>
                    <!-- Add this button in the header section -->
                    <a href="../Sprite-Assembly/Sprite Compiler/index.html" class="btn btn-outline-info">
                        <i class="bi bi-box-arrow-right"></i> Go to Sprite Compiler
                    </a>
                </div>
            <div class="col-lg-6">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <i class="fas fa-file-code feature-icon"></i> MonoBehaviour JSON Files
                        </div>
                        <button class="btn btn-sm btn-outline-danger" id="clear-json-btn" disabled>
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="drop-zone mb-3" id="json-drop-zone">
                            <i class="fas fa-cloud-upload-alt fa-2x mb-2"></i>
                            <p>Drag & drop JSON files here or click the button below</p>
                            <small class="text-muted">(Files from Unity sprite atlases)</small>
                        </div>
                        <div class="file-list" id="json-file-list">
                            <div class="text-muted text-center py-4">
                                <i class="fas fa-file-import fa-2x mb-2"></i>
                                <p>No JSON files selected</p>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <input type="file" id="json-file-input" class="d-none" accept=".json" multiple>
                            <button class="btn btn-primary flex-grow-1" onclick="document.getElementById('json-file-input').click()">
                                <i class="fas fa-plus-circle"></i> Add JSON Files
                            </button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <i class="fas fa-image feature-icon"></i> Texture Files
                        </div>
                        <button class="btn btn-sm btn-outline-danger" id="clear-texture-btn" disabled>
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="drop-zone mb-3" id="texture-drop-zone">
                            <i class="fas fa-cloud-upload-alt fa-2x mb-2"></i>
                            <p>Drag & drop texture files here or click the button below</p>
                            <small class="text-muted">(PNG, JPG, or other image files)</small>
                        </div>
                        <div class="file-list" id="texture-file-list">
                            <div class="text-muted text-center py-4">
                                <i class="fas fa-file-image fa-2x mb-2"></i>
                                <p>No texture files selected</p>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <input type="file" id="texture-file-input" class="d-none" accept="image/*" multiple>
                            <button class="btn btn-primary flex-grow-1" onclick="document.getElementById('texture-file-input').click()">
                                <i class="fas fa-plus-circle"></i> Add Texture Files
                            </button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-cogs feature-icon"></i> Processing Options
                    </div>
                    <div class="card-body">
                        <div class="d-grid gap-2">
                            <button class="btn btn-success btn-lg" id="process-btn" disabled>
                                <i class="fas fa-gear"></i> Process Atlas
                            </button>
                        </div>
                        <div class="status-bar mt-3">
                            <div id="status-message">Ready to process files</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-lg-6">
                <div class="right-panel">
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center sticky-preview">
                            <div>
                                <i class="fas fa-expand feature-icon"></i> Sprite Preview
                            </div>
                            <button class="btn btn-sm btn-outline-secondary" id="clear-preview-btn" disabled>
                                <i class="fas fa-times"></i> Clear Preview
                            </button>
                        </div>
                        <div class="card-body">
                            <div class="preview-container" id="sprite-preview-container">
                                <div id="sprite-preview-placeholder" class="text-muted text-center p-3">
                                    <i class="fas fa-magnifying-glass fa-3x mb-3"></i>
                                    <p>Select a sprite to preview</p>
                                </div>
                                <img id="sprite-preview-image" class="preview-image d-none">
                            </div>
                            <div id="sprite-info" class="mt-3 text-center d-none">
                                <h5 id="sprite-name"></h5>
                                <p id="sprite-dimensions" class="text-muted"></p>
                                <a id="sprite-download-link" class="btn btn-sm btn-primary">
                                    <i class="fas fa-download"></i> Download This Sprite
                                </a>
                            </div>
                        </div>
                    </div>

                    <div class="card mt-4">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <div>
                                <i class="fas fa-cubes feature-icon"></i> Extracted Sprites
                            </div>
                            <div>
                                <button class="btn btn-sm btn-outline-secondary" id="clear-sprites-btn" disabled>
                                    <i class="fas fa-trash"></i> Clear All
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="selection-controls">
                                <button class="btn btn-sm btn-outline-primary" id="select-all-btn" disabled>
                                    <i class="fas fa-check-square"></i> Select All
                                </button>
                                <button class="btn btn-sm btn-outline-primary" id="deselect-all-btn" disabled>
                                    <i class="fas fa-square"></i> Deselect All
                                </button>
                                <button class="btn btn-sm btn-success" id="download-selected-btn" disabled>
                                    <i class="fas fa-download"></i> Download Selected
                                </button>
                            </div>
                            <div class="sprites-container" id="sprites-container">
                                <div class="text-muted text-center py-4">
                                    <i class="fas fa-cubes fa-3x mb-3"></i>
                                    <p>Process an atlas to see extracted sprites here</p>
                                    <small class="text-muted">Click on any sprite to preview it</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Button -->
    <button class="btn btn-primary info-button" data-bs-toggle="modal" data-bs-target="#infoModal">
        <i class="fas fa-info"></i>
    </button>

    <!-- Bootstrap -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Application state
        const appState = {
            jsonFiles: [],
            textureFiles: [],
            extractedSprites: [],
            currentPreviewSprite: null,
            selectedSprites: new Set()
        };

        // DOM elements
        const jsonFileInput = document.getElementById('json-file-input');
        const textureFileInput = document.getElementById('texture-file-input');
        const jsonFileList = document.getElementById('json-file-list');
        const textureFileList = document.getElementById('texture-file-list');
        const clearJsonBtn = document.getElementById('clear-json-btn');
        const clearTextureBtn = document.getElementById('clear-texture-btn');
        const processBtn = document.getElementById('process-btn');
        const spritesContainer = document.getElementById('sprites-container');
        const spritePreviewImage = document.getElementById('sprite-preview-image');
        const spritePreviewPlaceholder = document.getElementById('sprite-preview-placeholder');
        const spriteInfo = document.getElementById('sprite-info');
        const spriteName = document.getElementById('sprite-name');
        const spriteDimensions = document.getElementById('sprite-dimensions');
        const spriteDownloadLink = document.getElementById('sprite-download-link');
        const clearPreviewBtn = document.getElementById('clear-preview-btn');
        const jsonDropZone = document.getElementById('json-drop-zone');
        const textureDropZone = document.getElementById('texture-drop-zone');
        const clearSpritesBtn = document.getElementById('clear-sprites-btn');
        const statusMessage = document.getElementById('status-message');
        const selectAllBtn = document.getElementById('select-all-btn');
        const deselectAllBtn = document.getElementById('deselect-all-btn');
        const downloadSelectedBtn = document.getElementById('download-selected-btn');

        // Initialize event listeners
        function initEventListeners() {
            jsonFileInput.addEventListener('change', handleJsonFilesAdded);
            textureFileInput.addEventListener('change', handleTextureFilesAdded);
            clearJsonBtn.addEventListener('click', clearAllJsonFiles);
            clearTextureBtn.addEventListener('click', clearAllTextureFiles);
            processBtn.addEventListener('click', processAtlas);
            clearPreviewBtn.addEventListener('click', clearSpritePreview);
            clearSpritesBtn.addEventListener('click', clearSprites);
            selectAllBtn.addEventListener('click', selectAllSprites);
            deselectAllBtn.addEventListener('click', deselectAllSprites);
            downloadSelectedBtn.addEventListener('click', downloadSelectedSprites);
            
            // Set up drag and drop
            setupDragAndDrop(jsonDropZone, handleJsonFilesAdded);
            setupDragAndDrop(textureDropZone, handleTextureFilesAdded);
        }

        // Set up drag and drop for a zone
        function setupDragAndDrop(dropZone, handler) {
            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', function() {
                dropZone.classList.remove('drag-over');
            });
            
            dropZone.addEventListener('drop', function(e) {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                
                if (e.dataTransfer.files.length > 0) {
                    handler({target: {files: e.dataTransfer.files}});
                }
            });
            
            dropZone.addEventListener('click', function() {
                const inputId = dropZone.id === 'json-drop-zone' ? 'json-file-input' : 'texture-file-input';
                document.getElementById(inputId).click();
            });
        }

        // Update drop zone visibility
        function updateDropZoneVisibility() {
            // JSON drop zone
            if (appState.jsonFiles.length > 0) {
                jsonDropZone.style.display = 'none';
            } else {
                jsonDropZone.style.display = 'block';
            }
            
            // Texture drop zone
            if (appState.textureFiles.length > 0) {
                textureDropZone.style.display = 'none';
            } else {
                textureDropZone.style.display = 'block';
            }
        }

        // Handle JSON files added
        function handleJsonFilesAdded(event) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                if (file.name.endsWith('.json') && !appState.jsonFiles.some(f => f.name === file.name)) {
                    appState.jsonFiles.push(file);
                    updateStatus(`Added JSON file: ${file.name}`);
                }
            });
            updateJsonFileList();
            updateProcessButtonState();
            updateDropZoneVisibility();
            event.target.value = ''; // Reset input
        }

        // Handle texture files added
        function handleTextureFilesAdded(event) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                if (file.type.startsWith('image/') && !appState.textureFiles.some(f => f.name === file.name)) {
                    appState.textureFiles.push(file);
                    updateStatus(`Added texture file: ${file.name}`);
                }
            });
            updateTextureFileList();
            updateProcessButtonState();
            updateDropZoneVisibility();
            event.target.value = ''; // Reset input
        }

        // Update JSON file list UI
        function updateJsonFileList() {
            if (appState.jsonFiles.length === 0) {
                jsonFileList.innerHTML = '<div class="text-muted text-center py-4"><i class="fas fa-file-import fa-2x mb-2"></i><p>No JSON files selected</p></div>';
                clearJsonBtn.disabled = true;
                return;
            }
            
            jsonFileList.innerHTML = '';
            appState.jsonFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div>${file.name}</div>
                    <div class="text-muted">${formatFileSize(file.size)}</div>
                `;
                jsonFileList.appendChild(fileItem);
            });
            
            clearJsonBtn.disabled = false;
        }

        // Update texture file list UI
        function updateTextureFileList() {
            if (appState.textureFiles.length === 0) {
                textureFileList.innerHTML = '<div class="text-muted text-center py-4"><i class="fas fa-file-image fa-2x mb-2"></i><p>No texture files selected</p></div>';
                clearTextureBtn.disabled = true;
                return;
            }
            
            textureFileList.innerHTML = '';
            appState.textureFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div>${file.name}</div>
                    <div class="text-muted">${formatFileSize(file.size)}</div>
                `;
                textureFileList.appendChild(fileItem);
            });
            
            clearTextureBtn.disabled = false;
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // Clear all JSON files
        function clearAllJsonFiles() {
            if (appState.jsonFiles.length === 0) {
                updateStatus("No JSON files to clear.");
                return;
            }
            
            const count = appState.jsonFiles.length;
            appState.jsonFiles = [];
            
            updateJsonFileList();
            updateProcessButtonState();
            updateDropZoneVisibility();
            
            updateStatus(`Cleared ${count} JSON files.`);
        }

        // Clear all texture files
        function clearAllTextureFiles() {
            if (appState.textureFiles.length === 0) {
                updateStatus("No texture files to clear.");
                return;
            }
            
            const count = appState.textureFiles.length;
            appState.textureFiles = [];
            
            updateTextureFileList();
            updateProcessButtonState();
            updateDropZoneVisibility();
            
            updateStatus(`Cleared ${count} texture files.`);
        }

        // Update process button state
        function updateProcessButtonState() {
            processBtn.disabled = appState.jsonFiles.length === 0 || 
                                 appState.textureFiles.length === 0;
        }

        // Update status message
        function updateStatus(message) {
            statusMessage.textContent = message;
        }

        // Display extracted sprites
        function displayExtractedSprites() {
            if (appState.extractedSprites.length === 0) {
                spritesContainer.innerHTML = `
                    <div class="text-muted text-center py-4">
                        <i class="fas fa-cubes fa-3x mb-3"></i>
                        <p>Process an atlas to see extracted sprites here</p>
                        <small class="text-muted">Click on any sprite to preview it</small>
                    </div>
                `;
                clearSpritesBtn.disabled = true;
                selectAllBtn.disabled = true;
                deselectAllBtn.disabled = true;
                downloadSelectedBtn.disabled = true;
                return;
            }
            
            let html = `
                <div class="sprite-grid">
            `;
            
            appState.extractedSprites.forEach((sprite, index) => {
                const isSelected = appState.selectedSprites.has(index);
                html += `
                    <div class="sprite-card ${isSelected ? 'selected' : ''}" onclick="previewSprite(${index})">
                        <input type="checkbox" class="sprite-checkbox" ${isSelected ? 'checked' : ''} 
                            onchange="toggleSpriteSelection(${index}, this.checked)">
                        <img src="${sprite.data}" class="sprite-preview mb-2">
                        <div class="small text-truncate" title="${sprite.name}">${sprite.name}</div>
                        <small class="text-muted">${sprite.width}x${sprite.height}</small>
                    </div>
                `;
            });
            
            html += `</div>`;
            spritesContainer.innerHTML = html;
            clearSpritesBtn.disabled = false;
            selectAllBtn.disabled = false;
            deselectAllBtn.disabled = false;
            updateDownloadButtonState();
        }

        // Toggle sprite selection
        function toggleSpriteSelection(index, isSelected) {
            if (isSelected) {
                appState.selectedSprites.add(index);
            } else {
                appState.selectedSprites.delete(index);
            }
            
            // Update UI
            const spriteCard = document.querySelectorAll('.sprite-card')[index];
            if (spriteCard) {
                spriteCard.classList.toggle('selected', isSelected);
            }
            
            updateDownloadButtonState();
        }

        // Select all sprites
        function selectAllSprites() {
            appState.selectedSprites = new Set([...Array(appState.extractedSprites.length).keys()]);
            displayExtractedSprites();
            updateStatus("All sprites selected.");
        }

        // Deselect all sprites
        function deselectAllSprites() {
            appState.selectedSprites.clear();
            displayExtractedSprites();
            updateStatus("All sprites deselected.");
        }

        // Update download button state
        function updateDownloadButtonState() {
            downloadSelectedBtn.disabled = appState.selectedSprites.size === 0;
        }

        // Preview a sprite
        function previewSprite(index) {
            const sprite = appState.extractedSprites[index];
            if (!sprite) return;
            
            spritePreviewImage.src = sprite.data;
            spritePreviewImage.classList.remove('d-none');
            spritePreviewPlaceholder.classList.add('d-none');
            spriteInfo.classList.remove('d-none');
            
            spriteName.textContent = `${sprite.name}.png`;
            spriteDimensions.textContent = `${sprite.width} × ${sprite.height} pixels`;
            spriteDownloadLink.href = sprite.data;
            spriteDownloadLink.download = `${sprite.name}.png`;
            
            appState.currentPreviewSprite = sprite;
            clearPreviewBtn.disabled = false;
        }

        // Clear sprite preview
        function clearSpritePreview() {
            spritePreviewImage.classList.add('d-none');
            spritePreviewPlaceholder.classList.remove('d-none');
            spriteInfo.classList.add('d-none');
            appState.currentPreviewSprite = null;
            clearPreviewBtn.disabled = true;
        }

        // Clear all sprites
        function clearSprites() {
            appState.extractedSprites = [];
            appState.selectedSprites.clear();
            displayExtractedSprites();
            clearSpritePreview();
            updateStatus("Cleared all extracted sprites.");
        }

        // Download selected sprites
        async function downloadSelectedSprites() {
            if (appState.selectedSprites.size === 0) {
                updateStatus("No sprites selected for download.");
                return;
            }
            
            try {
                const selectedIndices = Array.from(appState.selectedSprites);
                updateStatus(`Downloading ${selectedIndices.length} sprites...`);
                
                for (let i = 0; i < selectedIndices.length; i++) {
                    const index = selectedIndices[i];
                    const sprite = appState.extractedSprites[index];
                    
                    // Create download link and trigger download
                    const link = document.createElement('a');
                    link.href = sprite.data;
                    link.download = `${sprite.name}.png`;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    updateStatus(`Downloaded ${i + 1}/${selectedIndices.length}: ${sprite.name}.png`);
                    
                    // Add small delay to avoid overwhelming the browser
                    if (i < selectedIndices.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                updateStatus("All selected sprites downloaded!");
                
            } catch (error) {
                updateStatus(`Error downloading files: ${error.message}`);
                console.error(error);
            }
        }

        // Match JSON to texture based on filename similarity
        function matchJsonToTexture(jsonFilename, textureFiles) {
            const jsonName = jsonFilename.replace('.json', '');
            
            // Try exact match first
            for (let i = 0; i < textureFiles.length; i++) {
                const textureName = textureFiles[i].name.split('.')[0];
                if (textureName === jsonName) {
                    return textureFiles[i];
                }
            }
            
            // Try partial match
            for (let i = 0; i < textureFiles.length; i++) {
                const textureName = textureFiles[i].name.split('.')[0];
                if (textureName.includes(jsonName) || jsonName.includes(textureName)) {
                    return textureFiles[i];
                }
            }
            
            // Return first texture if no match found
            return textureFiles.length > 0 ? textureFiles[0] : null;
        }

        // Process atlas files
        async function processAtlas() {
            if (appState.jsonFiles.length === 0 || appState.textureFiles.length === 0) {
                updateStatus("Error: Please add JSON and texture files first.");
                return;
            }
            
            // Show processing state
            processBtn.disabled = true;
            processBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
            updateStatus("Processing started...");
            
            try {
                appState.extractedSprites = [];
                appState.selectedSprites.clear();
                let totalExtracted = 0;
                
                for (const jsonFile of appState.jsonFiles) {
                    updateStatus(`Processing JSON: ${jsonFile.name}`);
                    
                    // Read JSON file
                    const jsonText = await readFileAsText(jsonFile);
                    const jsonData = JSON.parse(jsonText);
                    
                    // Find matching texture
                    const textureFile = matchJsonToTexture(jsonFile.name, appState.textureFiles);
                    
                    if (textureFile) {
                        updateStatus(`Matched texture: ${textureFile.name}`);
                        
                        // Extract sprites
                        const extracted = await extractSpritesFromAtlas(jsonData, textureFile, jsonFile.name);
                        totalExtracted += extracted;
                        
                        updateStatus(`Extracted ${extracted} sprites from ${jsonFile.name}`);
                    } else {
                        updateStatus(`No matching texture found for ${jsonFile.name}`);
                    }
                }
                
                if (totalExtracted > 0) {
                    // Auto-select all extracted sprites
                    appState.selectedSprites = new Set([...Array(totalExtracted).keys()]);
                    displayExtractedSprites();
                    updateStatus(`Processing complete! ${totalExtracted} sprites extracted and selected.`);
                } else {
                    spritesContainer.innerHTML = '<div class="text-muted text-center py-4"><i class="fas fa-exclamation-triangle fa-2x mb-2"></i><p>No sprites were extracted. Check your files and try again.</p></div>';
                    updateStatus('No sprites were extracted. Check your files and try again.');
                }
                
            } catch (error) {
                updateStatus(`Error during processing: ${error.message}`);
                console.error(error);
            } finally {
                // Restore process button
                processBtn.disabled = false;
                processBtn.innerHTML = '<i class="fas fa-gear"></i> Process Atlas';
            }
        }

        // Read file as text
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(e);
                reader.readAsText(file);
            });
        }

        // Read file as data URL (for images)
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(e);
                reader.readAsDataURL(file);
            });
        }

        // Extract sprites from atlas
        async function extractSpritesFromAtlas(jsonData, textureFile, jsonFileName) {
            try {
                // Load texture as image
                const textureDataURL = await readFileAsDataURL(textureFile);
                
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = function() {
                        const atlasWidth = img.width;
                        const atlasHeight = img.height;
                        
                        updateStatus(`Atlas texture size: ${atlasWidth}x${atlasHeight}`);
                        
                        // Create canvas for image manipulation
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = atlasWidth;
                        canvas.height = atlasHeight;
                        ctx.drawImage(img, 0, 0);
                        
                        // Get sprite data array
                        const spritesData = jsonData.DataArray || [];
                        let extractedCount = 0;
                        let processed = 0;
                        
                        const processNextSprite = () => {
                            if (processed >= spritesData.length) {
                                resolve(extractedCount);
                                return;
                            }
                            
                            const spriteData = spritesData[processed++];
                            setTimeout(() => processSprite(spriteData), 0);
                        };
                        
                        const processSprite = (spriteData) => {
                            const spriteName = spriteData.SpriteName || `sprite_${extractedCount}`;
                            const position = spriteData.Position || {};
                            const size = spriteData.Size || {};
                            const offset = spriteData.Offset || {};
                            const originalSize = spriteData.OriginalSize || {};
                            
                            // Get position and size from atlas
                            const x = position.x || 0;
                            const y = position.y || 0;
                            const width = size.x || 0;
                            const height = size.y || 0;
                            
                            // Unity uses bottom-left origin, canvas uses top-left
                            const yCorrected = atlasHeight - y - height;
                            
                            if (width > 0 && height > 0) {
                                // Ensure coordinates are within bounds
                                const safeX = Math.max(0, Math.min(x, atlasWidth - 1));
                                const safeY = Math.max(0, Math.min(yCorrected, atlasHeight - 1));
                                
                                // Ensure crop region doesn't exceed atlas bounds
                                const cropRight = Math.min(safeX + width, atlasWidth);
                                const cropBottom = Math.min(safeY + height, atlasHeight);
                                
                                const actualWidth = cropRight - safeX;
                                const actualHeight = cropBottom - safeY;
                                
                                // Create sprite canvas
                                const spriteCanvas = document.createElement('canvas');
                                const spriteCtx = spriteCanvas.getContext('2d');
                                spriteCanvas.width = actualWidth;
                                spriteCanvas.height = actualHeight;
                                
                                // Extract sprite region
                                spriteCtx.drawImage(
                                    canvas,
                                    safeX, safeY, actualWidth, actualHeight,
                                    0, 0, actualWidth, actualHeight
                                );
                                
                                // Handle offset and original size if needed
                                if (offset.x !== undefined && offset.y !== undefined && 
                                    originalSize.x !== undefined && originalSize.y !== undefined) {
                                    const offsetX = offset.x || 0;
                                    const offsetY = offset.y || 0;
                                    const origWidth = originalSize.x || width;
                                    const origHeight = originalSize.y || height;
                                    
                                    if (origWidth > actualWidth || origHeight > actualHeight) {
                                        // Create a canvas with the original size
                                        const paddedCanvas = document.createElement('canvas');
                                        const paddedCtx = paddedCanvas.getContext('2d');
                                        paddedCanvas.width = origWidth;
                                        paddedCanvas.height = origHeight;
                                        
                                        // Clear with transparent background
                                        paddedCtx.clearRect(0, 0, origWidth, origHeight);
                                        
                                        // Calculate paste position (Unity uses center-based coordinates)
                                        const pasteX = offsetX;
                                        const pasteY = origHeight - offsetY - actualHeight; // Flip Y coordinate
                                        
                                        // Ensure paste position is within bounds
                                        const safePasteX = Math.max(0, Math.min(pasteX, origWidth - actualWidth));
                                        const safePasteY = Math.max(0, Math.min(pasteY, origHeight - actualHeight));
                                        
                                        // Draw the extracted sprite onto the padded canvas
                                        paddedCtx.drawImage(
                                            spriteCanvas,
                                            safePasteX, safePasteY
                                        );
                                        
                                        // Replace sprite canvas with padded version
                                        spriteCanvas.width = origWidth;
                                        spriteCanvas.height = origHeight;
                                        spriteCtx.drawImage(paddedCanvas, 0, 0);
                                        
                                        updateStatus(`Padded ${spriteName} to original size: ${origWidth}x${origHeight}`);
                                    }
                                }
                                
                                // Convert canvas to data URL and store
                                const spriteDataURL = spriteCanvas.toDataURL('image/png');
                                appState.extractedSprites.push({
                                    name: spriteName,
                                    data: spriteDataURL,
                                    width: spriteCanvas.width,
                                    height: spriteCanvas.height,
                                    source: jsonFileName
                                });
                                
                                extractedCount++;
                                updateStatus(`Extracted: ${spriteName}.png (${spriteCanvas.width}x${spriteCanvas.height})`);
                                processNextSprite();
                            } else {
                                updateStatus(`Skipping ${spriteName}: invalid size (${width}x${height})`);
                                processNextSprite();
                            }
                        };
                        
                        processNextSprite();
                    };
                    img.src = textureDataURL;
                });
                
            } catch (error) {
                updateStatus(`Error extracting sprites: ${error.message}`);
                console.error(error);
                return 0;
            }
        }

        // Initialize the application
        function init() {
            initEventListeners();
            updateStatus("Application started. Ready to process Unity sprite atlases.");
            updateDropZoneVisibility();
        }

        // Start the application when page loads
        window.onload = init;

        // Make functions available globally for HTML onclick handlers
        window.previewSprite = previewSprite;
        window.clearSprites = clearSprites;
        window.toggleSpriteSelection = toggleSpriteSelection;
    </script>
</body>
</html>
